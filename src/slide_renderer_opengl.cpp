#define GL_NUM_EXTENSIONS                 0x821D

#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D

#define GL_TEXTURE_3D                     0x806F

#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7

#define GL_DEBUG_SEVERITY_HIGH            0x9146
#define GL_DEBUG_SEVERITY_MEDIUM          0x9147
#define GL_DEBUG_SEVERITY_LOW             0x9148
#define GL_DEBUG_TYPE_MARKER              0x8268
#define GL_DEBUG_TYPE_PUSH_GROUP          0x8269
#define GL_DEBUG_TYPE_POP_GROUP           0x826A
#define GL_DEBUG_SEVERITY_NOTIFICATION    0x826B

#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA

#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D

#define GL_FRAMEBUFFER_SRGB               0x8DB9
#define GL_SRGB8_ALPHA8                   0x8C43

#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83

#define GL_TEXTURE_2D_ARRAY               0x8C1A

#define GL_FRAMEBUFFER                    0x8D40
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5

#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_DEPTH_COMPONENT32F             0x8CAC

#define GL_RED_INTEGER                    0x8D94
#define GL_GREEN_INTEGER                  0x8D95
#define GL_BLUE_INTEGER                   0x8D96

#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C

#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_MAX_SAMPLES                    0x8D57
#define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F

#define GL_BGRA_EXT                       0x80E1

#define OPENGL_DEPTH_COMPONENT_KIND GL_DEPTH_COMPONENT32F

global GLenum opengl_all_color_attachments[] = {
    GL_COLOR_ATTACHMENT0,
    GL_COLOR_ATTACHMENT1,
    GL_COLOR_ATTACHMENT2,
    GL_COLOR_ATTACHMENT3,
    GL_COLOR_ATTACHMENT4,
    GL_COLOR_ATTACHMENT5,
    GL_COLOR_ATTACHMENT6,
    GL_COLOR_ATTACHMENT7,
    GL_COLOR_ATTACHMENT8,
    GL_COLOR_ATTACHMENT9,
    GL_COLOR_ATTACHMENT10,
    GL_COLOR_ATTACHMENT11,
    GL_COLOR_ATTACHMENT12,
    GL_COLOR_ATTACHMENT13,
    GL_COLOR_ATTACHMENT14,
    GL_COLOR_ATTACHMENT15,
    GL_COLOR_ATTACHMENT16,
    GL_COLOR_ATTACHMENT17,
    GL_COLOR_ATTACHMENT18,
    GL_COLOR_ATTACHMENT19,
    GL_COLOR_ATTACHMENT20,
    GL_COLOR_ATTACHMENT21,
    GL_COLOR_ATTACHMENT22,
    GL_COLOR_ATTACHMENT23,
    GL_COLOR_ATTACHMENT24,
    GL_COLOR_ATTACHMENT25,
    GL_COLOR_ATTACHMENT26,
    GL_COLOR_ATTACHMENT27,
    GL_COLOR_ATTACHMENT28,
    GL_COLOR_ATTACHMENT29,
    GL_COLOR_ATTACHMENT30,
    GL_COLOR_ATTACHMENT31,
};

global const char* global_shader_header_code = R"FOO(
    #define m4x4 mat4
    #define f32 float
    #define v4 vec4
    #define v3 vec3
    #define v2 vec2
    #define V4 vec4
    #define V3 vec3
    #define V2 vec2
    #define Lerp(a, t, b) mix(a, b, t)
    #define Clamp01(t) clamp(t, 0, 1)
    #define Clamp(min, t, max) clamp(t, min, max)
    #define Inner(a, b) dot(a, b)
    
    f32 Clamp01MapToRange(f32 Min, f32 t, f32 Max)
    {
        f32 Range = Max - Min;
        f32 Result = Clamp01((t - Min) / Range);
        
        return(Result);
    }
    
    )FOO";

GL_DEBUG_CALLBACK(opengl_debug_callback) {
    if (severity == GL_DEBUG_SEVERITY_HIGH) {
        char* error_message = (char*)message;
        ASSERT(!"Opengl Error Encountered!");
    }
}

internal Opengl_Info
opengl_get_info(b32 is_modern_context) {
    Opengl_Info result = {};
    
    result.modern_context = is_modern_context;
    result.vendor = (char*)glGetString(GL_VENDOR);
    result.renderer = (char*)glGetString(GL_RENDERER);
    result.version = (char*)glGetString(GL_VERSION);
    
    if (result.modern_context) {
        result.shading_language_version =
            (char*)glGetString(GL_SHADING_LANGUAGE_VERSION);
    } else {
        result.shading_language_version = "(none)";
    }
    
    if (glGetStringi) {
        GLint extension_count = 0;
        glGetIntegerv(GL_NUM_EXTENSIONS, &extension_count);
        
        for (GLint extension_index = 0;
             extension_index < extension_count;
             ++extension_index) {
            char* ext_name = (char*)glGetStringi(GL_EXTENSIONS,
                                                 extension_index);
            
            if (match(ext_name, "GL_EXT_texture_sRGB")) {
                result.opengl_ext_texture_srgb = true;
            } else if (match(ext_name, "GL_EXT_framebuffer_sRGB")) {
                result.opengl_ext_framebuffer_srgb = true;
            } else if (match(ext_name, "GL_ARB_framebuffer_sRGB")) {
                result.opengl_ext_framebuffer_srgb = true;
            } else if (match(ext_name, "GL_ARB_framebuffer_object")) {
                result.opengl_arb_framebuffer_object = true;
            }
        }
    }
    
    const char* major_at = result.version;
    const char* minor_at = 0;
    for (const char* at = result.version; *at; ++at) {
        if (at[0] == '.') {
            minor_at = at + 1;
            break;
        }
    }
    
    s32 major = 1;
    s32 minor = 1;
    if (minor_at) {
        S32_Conversion_Result major_result = to_s32(major_at);
        if (major_result.success) {
            major = major_result.value;
        }
        
        S32_Conversion_Result minor_result = to_s32(minor_at);
        if (minor_result.success) {
            minor = minor_result.value;
        }
    }
    
    if ((major > 2 ) || ((major == 2) && (minor >= 1))) {
        result.opengl_ext_texture_srgb = true;
    }
    
    return result;
}

inline GLuint
get_texture_handle_for(Opengl* opengl, Renderer_Texture texture) {
    ASSERT(texture.index < opengl->max_texture_handle_count);
    
    GLuint result = opengl->texture_handles[texture.index];
    return result;
}

internal void
opengl_init_texture(Opengl* opengl, Renderer_Texture texture,
                    Renderer_Texture_Format::Type in_format,
                    Renderer_Texture_Format::Type out_format,
                    void* data) {
    using namespace Renderer_Texture_Format;
    
    GLuint handle = get_texture_handle_for(opengl, texture);
    glBindTexture(GL_TEXTURE_2D, handle);
    
    GLenum format = 0;
    switch (in_format) {
        case RGBA: {
            format = GL_RGBA;
        } break;
        
        case BGRA: {
            format = GL_BGRA_EXT;
        } break;
        
        case RED: {
            format = GL_RED;
        } break;
        
        INVALID_DEFAULT_CASE();
    }
    
    GLint internal_format = 0;
    switch (out_format) {
        case RGBA: {
            internal_format = GL_RGBA8;
        } break;
        
        case RED: {
            internal_format = GL_RED;
        } break;
        
        INVALID_DEFAULT_CASE();
    }
    
    glTexImage2D(GL_TEXTURE_2D, 0,
                 internal_format,
                 texture.width, texture.height, 0,
                 format, GL_UNSIGNED_BYTE, data);
    
    glBindTexture(GL_TEXTURE_2D, 0);
}

internal void
opengl_manage_textures(Opengl* opengl) {
    Renderer_Texture_Queue* queue = &opengl->header.texture_queue;
    while (queue->entry_count) {
        Renderer_Texture_Queue_Entry* entry =
            &queue->entries[queue->first_entry_index];
        opengl_init_texture(opengl, entry->texture,
                            entry->in_format, entry->out_format,
                            entry->data);
        
        --queue->entry_count;
        ++queue->first_entry_index;
        if (queue->first_entry_index >= ARRAY_COUNT(queue->entries)) {
            queue->first_entry_index = 0;
        }
    }
}

internal b32
is_valid_array(GLint index) {
    b32 result = (index != -1);
    return result;
}

internal void
use_program_begin(Opengl_Program_Common* prog) {
    glUseProgram(prog->prog_handle);
    
    GLint p_array = prog->vert_p_id;
    GLint uv_array = prog->vert_uv_id;
    GLint c_array = prog->vert_color_id;
    
    if (is_valid_array(p_array)) {
        glEnableVertexAttribArray(p_array);
        glVertexAttribPointer(p_array, 4, GL_FLOAT, false,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, p));
    }
    
    if (is_valid_array(uv_array)) {
        glEnableVertexAttribArray(uv_array);
        glVertexAttribPointer(uv_array, 2, GL_FLOAT, false,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, uv));
    }
    
    if (is_valid_array(c_array)) {
        glEnableVertexAttribArray(c_array);
        glVertexAttribPointer(c_array, 4, GL_UNSIGNED_BYTE, true,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, color));
    }
}

internal void
use_program_begin(Basic_Program* prog, Render_Setup* setup) {
    use_program_begin(&prog->common);
    
    glUniformMatrix4fv(prog->mvp_id, 1, GL_FALSE, setup->proj.e[0]);
    glUniform1i(prog->texture_sampler_id, 0);
}

internal void
use_program_end(Opengl_Program_Common* prog) {
    glUseProgram(0);
    
    GLint p_array = prog->vert_p_id;
    GLint uv_array = prog->vert_uv_id;
    GLint c_array = prog->vert_color_id;
    
    if (is_valid_array(p_array)) {
        glDisableVertexAttribArray(p_array);
    }
    
    if (is_valid_array(uv_array)) {
        glDisableVertexAttribArray(uv_array);
    }
    
    if (is_valid_array(c_array)) {
        glDisableVertexAttribArray(c_array);
    }
}

internal void
free_program(Opengl_Program_Common* program) {
    glDeleteProgram(program->prog_handle);
    program->prog_handle = 0;
}

internal GLuint
opengl_create_program(const char* defines, const char* header_code,
                      const char* vertex_code, const char* fragment_code,
                      Opengl_Program_Common* result) {
    GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
    const GLchar* vertex_shader_code[] = {defines, header_code, vertex_code};
    glShaderSource(vertex_shader_id, ARRAY_COUNT(vertex_shader_code),
                   vertex_shader_code, 0);
    glCompileShader(vertex_shader_id);
    
    GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);
    const GLchar* fragment_shader_code[] = {defines, header_code, fragment_code};
    glShaderSource(fragment_shader_id, ARRAY_COUNT(fragment_shader_code),
                   fragment_shader_code, 0);
    glCompileShader(fragment_shader_id);
    
    GLuint program_id = glCreateProgram();
    glAttachShader(program_id, vertex_shader_id);
    glAttachShader(program_id, fragment_shader_id);
    glLinkProgram(program_id);
    
    glValidateProgram(program_id);
    GLint linked = false;
    glGetProgramiv(program_id, GL_LINK_STATUS, &linked);
    
    if (!linked) {
        GLsizei ignored;
        char vertex_errors[4096];
        char fragment_errors[4096];
        char program_errors[4096];
        glGetShaderInfoLog(vertex_shader_id, sizeof(vertex_errors),
                           &ignored, vertex_errors);
        glGetShaderInfoLog(fragment_shader_id, sizeof(fragment_errors),
                           &ignored, fragment_errors);
        glGetProgramInfoLog(program_id, sizeof(program_errors),
                            &ignored, program_errors);
        
        ASSERT(!"Shader Validation Failed!");
    }
    
    glDeleteShader(vertex_shader_id);
    glDeleteShader(fragment_shader_id);
    
    result->prog_handle = program_id;
    result->vert_p_id = glGetAttribLocation(program_id, "vert_p");
    result->vert_uv_id = glGetAttribLocation(program_id, "vert_uv");
    result->vert_color_id = glGetAttribLocation(program_id, "vert_color");
    
    return program_id;
}
internal void
compile_text_program(Opengl* opengl, Basic_Program* result) {
    char defines[1024];
    format_string(defines, sizeof(defines),
                  "#version 330\n");
    
    const char* vertex_code = R"FOO(
    // Vertex code
    in v4 vert_p;
      in v2 vert_uv;
    in v4 vert_color;
    
    uniform m4x4 mvp;
    
    out v2 frag_uv;
    out v4 frag_color;
    
    void main(void)
    {
        gl_Position = mvp * vert_p;
        frag_uv = vert_uv;
        frag_color = vert_color;
    }
    )FOO";
    
    const char* fragment_code = R"FOO(
    // Fragment code
    
    in vec2 frag_uv;
    in vec4 frag_color;
    
    uniform sampler2D texture_sampler;
    
    out vec4 result_color;
    
    void main(void)
    {
        vec4 tex_sample = texture(texture_sampler, frag_uv);
        
        if(tex_sample.r > 0)
        {
            v4 mod_color = frag_color * vec4(1, 1, 1, tex_sample.r);
            result_color = mod_color;
        }
        else
        {
            discard;
        }
    }
    )FOO";
    
    GLuint prog = opengl_create_program(defines, global_shader_header_code,
                                        vertex_code, fragment_code, &result->common);
    
    result->mvp_id = glGetUniformLocation(prog, "mvp");
    result->texture_sampler_id = glGetUniformLocation(prog, "texture_sampler");
}

internal void
compile_basic_program(Opengl* opengl, Basic_Program* result) {
    char defines[1024];
    format_string(defines, sizeof(defines),
                  "#version 330\n");
    
    const char* vertex_code = R"FOO(
    // Vertex code
    in v4 vert_p;
      in v2 vert_uv;
    in v4 vert_color;
    
    uniform m4x4 mvp;
    
    out v2 frag_uv;
    out v4 frag_color;
    
    void main(void)
    {
        gl_Position = mvp * vert_p;
        frag_uv = vert_uv;
        frag_color = vert_color;
    }
    )FOO";
    
    const char* fragment_code = R"FOO(
    // Fragment code
    in vec2 frag_uv;
    in vec4 frag_color;
    
    uniform sampler2D texture_sampler;
    
    out vec4 result_color;
    
    void main(void)
    {
        vec4 tex_sample = texture(texture_sampler, frag_uv);
        
        if(tex_sample.a > 0)
        {
            v4 mod_color = frag_color * tex_sample;
    result_color = mod_color;
    }
        else
        {
            discard;
        }
    }
    )FOO";
    
    GLuint prog = opengl_create_program(defines, global_shader_header_code,
                                        vertex_code, fragment_code, &result->common);
    
    result->mvp_id = glGetUniformLocation(prog, "mvp");
    result->texture_sampler_id = glGetUniformLocation(prog, "texture_sampler");
}

internal void
opengl_init(Opengl* opengl, Opengl_Info info) {
    opengl->default_sprite_texture_format = Renderer_Texture_Format::RGBA;
    
#if SLIDE_DEVELOPER
    if(glDebugMessageCallbackARB)
    {
        glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
        glDebugMessageCallbackARB(opengl_debug_callback, 0);
    }
#endif // #if SLIDE_DEVELOPER
    
    GLuint dummy_vertex_array;
    glGenVertexArrays(1, &dummy_vertex_array);
    glBindVertexArray(dummy_vertex_array);
    
    glGenBuffers(1, &opengl->vertex_buffer);
    glBindBuffer(GL_ARRAY_BUFFER, opengl->vertex_buffer);
    
    compile_basic_program(opengl, &opengl->basic_prog);
    compile_text_program(opengl, &opengl->text_prog);
    
    glGenTextures(opengl->max_texture_handle_count, opengl->texture_handles);
    for (u32 handle_index = 0;
         handle_index < opengl->max_texture_handle_count;
         ++handle_index) {
        glBindTexture(GL_TEXTURE_2D, opengl->texture_handles[handle_index]);
        
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    }
    
    for (u32 y = 0; y < 4; ++y) {
        for (u32 x = 0; x < 4; ++x) {
            opengl->white[y][x] = 0xFFFFFFFF;
        }
    }
    
    opengl->white_texture = refer_to_texture(0, 4, 4);
    opengl_init_texture(opengl, opengl->white_texture,
                        Renderer_Texture_Format::BGRA,
                        opengl->default_sprite_texture_format,
                        opengl->white[0]);
    
    opengl->render_commands.next_texture_handle_index = 1;
}

internal Render_Commands*
opengl_begin_frame(Opengl* opengl, Vector2u render_dim) {
    Render_Commands* commands = &opengl->render_commands;
    
    commands->render_dim = render_dim;
    
    commands->max_push_buffer_size = sizeof(opengl->push_buffer_memory);
    commands->push_buffer_base = opengl->push_buffer_memory;
    commands->push_buffer_data_at = opengl->push_buffer_memory;
    
    commands->max_vertex_count = opengl->max_vertex_count;
    commands->vertex_count = 0;
    commands->vertex_array = opengl->vertex_array;
    
    commands->quad_textures = opengl->bitmap_array;
    commands->white_texture = opengl->white_texture;
    
    commands->max_texture_handle_count = opengl->max_texture_handle_count;
    
    commands->texture_queue = &opengl->header.texture_queue;
    
    return commands;
}

internal void
flush_textured_quads_entry(Opengl* opengl, Render_Commands* commands,
                           Render_Entry_Textured_Quads* entry) {
    glBufferData(GL_ARRAY_BUFFER,
                 commands->vertex_count * sizeof(Textured_Vertex),
                 commands->vertex_array,
                 GL_STREAM_DRAW);
    
    for (u32 vert_index = entry->vertex_array_offset;
         vert_index < (entry->vertex_array_offset + 4 * entry->quad_count);
         vert_index += 4) {
        Renderer_Texture texture = commands->quad_textures[vert_index >> 2];
        GLuint texture_handle = get_texture_handle_for(opengl, texture);
        glBindTexture(GL_TEXTURE_2D, texture_handle);
        glDrawArrays(GL_TRIANGLE_STRIP, vert_index, 4);
    }
}

internal Vector4
store_color(Vector4 source) {
    Vector4 dest;
    dest.a = source.a;
    dest.r = dest.a * source.r;
    dest.g = dest.a * source.g;
    dest.b = dest.a * source.b;
    
    return dest;
}

internal void
opengl_end_frame(Opengl* opengl, Render_Commands* commands) {
    glDepthMask(GL_TRUE);
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_SAMPLE_ALPHA_TO_COVERAGE);
    glEnable(GL_SAMPLE_ALPHA_TO_ONE);
    glEnable(GL_MULTISAMPLE);
    
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    
    glClearDepth(1.0f);
    glClearColor(0, 0, 0, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    glEnable(GL_SCISSOR_TEST);
    glViewport(0, 0, commands->render_dim.width,
               commands->render_dim.height);
    glScissor(0, 0, commands->render_dim.width,
              commands->render_dim.height);
    
    opengl_manage_textures(opengl);
    
#if 0
    Vector4 color_v = store_color(make_v4(1, 0, 0, 1));
    u32 color = rgba_pack_4x8(255.0f * color_v);
    
    Textured_Vertex verts[4] = {};
    
    verts[0].p = make_v4(100, 100, 0, 1);
    verts[0].uv = make_v2(0, 1);
    verts[0].color = color;
    
    verts[1].p = make_v4(100, 148, 0, 1);
    verts[1].uv = make_v2(0, 0);
    verts[1].color = color;
    
    verts[2].p = make_v4(148, 100, 0, 1);
    verts[2].uv = make_v2(1, 1);
    verts[2].color = color;
    
    verts[3].p = make_v4(148, 148, 0, 1);
    verts[3].uv = make_v2(1, 0);
    verts[3].color = color;
    
    Render_Setup setup = {};
    setup.fog_start_distance = 0.0f;
    setup.fog_end_distance = 1.0f;
    setup.clip_rect = rect_min_dim(0, 0, commands->render_dim.width,
                                   commands->render_dim.height);
    setup.proj = orthographic_projection(0, (f32)commands->render_dim.width,
                                         0, (f32)commands->render_dim.height,
                                         -1.0f, 1.0f);
    
    use_program_begin(&opengl->basic_prog, &setup);
    
    glBufferData(GL_ARRAY_BUFFER,
                 sizeof(verts),
                 verts,
                 GL_STREAM_DRAW);
    
    glBindTexture(GL_TEXTURE_2D, get_texture_handle_for(opengl, opengl->white_texture));
    
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    
    use_program_end(&opengl->text_prog.common);
#else
    for (u8* header_at = commands->push_buffer_base;
         header_at < commands->push_buffer_data_at;) {
        Render_Group_Entry_Header* header =
            (Render_Group_Entry_Header*)header_at;
        header_at += sizeof(Render_Group_Entry_Header);
        void* data = (u8*)header + sizeof(*header);
        
        switch (header->kind) {
            case Render_Group_Entry_Kind::TEXTURED_QUADS: {
                header_at += sizeof(Render_Entry_Textured_Quads);
                Render_Entry_Textured_Quads* entry =
                    (Render_Entry_Textured_Quads*)data;
                
                Render_Setup* setup = &entry->setup;
                
                use_program_begin(&opengl->basic_prog, setup);
                flush_textured_quads_entry(opengl, commands, entry);
                use_program_end(&opengl->basic_prog.common);
            } break;
            
            case Render_Group_Entry_Kind::TEXT: {
                header_at += sizeof(Render_Entry_Textured_Quads);
                Render_Entry_Textured_Quads* entry =
                    (Render_Entry_Textured_Quads*)data;
                
                Render_Setup* setup = &entry->setup;
                
                use_program_begin(&opengl->text_prog, setup);
                flush_textured_quads_entry(opengl, commands, entry);
                use_program_end(&opengl->text_prog.common);
            } break;
        }
    }
#endif // #if 0
}
