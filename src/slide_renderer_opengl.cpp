#define GL_NUM_EXTENSIONS                 0x821D

#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D

#define GL_TEXTURE_3D                     0x806F

#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7

#define GL_DEBUG_SEVERITY_HIGH            0x9146
#define GL_DEBUG_SEVERITY_MEDIUM          0x9147
#define GL_DEBUG_SEVERITY_LOW             0x9148
#define GL_DEBUG_TYPE_MARKER              0x8268
#define GL_DEBUG_TYPE_PUSH_GROUP          0x8269
#define GL_DEBUG_TYPE_POP_GROUP           0x826A
#define GL_DEBUG_SEVERITY_NOTIFICATION    0x826B

#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA

#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D

#define GL_FRAMEBUFFER_SRGB               0x8DB9
#define GL_SRGB8_ALPHA8                   0x8C43

#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83

#define GL_TEXTURE_2D_ARRAY               0x8C1A

#define GL_FRAMEBUFFER                    0x8D40
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5

#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_DEPTH_COMPONENT32F             0x8CAC

#define GL_RED_INTEGER                    0x8D94
#define GL_GREEN_INTEGER                  0x8D95
#define GL_BLUE_INTEGER                   0x8D96

#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C

#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_MAX_SAMPLES                    0x8D57
#define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F

#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_COMPARE_REF_TO_TEXTURE         0x884E

#define OPENGL_DEPTH_COMPONENT_KIND GL_DEPTH_COMPONENT32F

#define OPENGL_FBO_COLOR_OUT_0  0x01
#define OPENGL_FBO_COLOR_OUT_1  0x02
#define OPENGL_FBO_COLOR_OUT_2  0x04
#define OPENGL_FBO_COLOR_OUT_3  0x08
#define OPENGL_FBO_DEPTH_OUT    0x10

internal void
opengl_bind_fbo(Renderer_Opengl* opengl, Opengl_Fbo* fbo) {
    if (fbo) {
        glViewport(0, 0, (GLsizei)fbo->w, (GLsizei)fbo->h);
        glBindFramebuffer(GL_FRAMEBUFFER, fbo->fbo);
    } else {
        glViewport(0, 0, (GLsizei)opengl->render_width,
                   (GLsizei)opengl->render_height);
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
    }
    
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,
                        GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    
    opengl->active_fbo = fbo;
}

internal Opengl_Fbo
opengl_make_fbo(u32 width, u32 height, u32 flags) {
    Opengl_Fbo fbo = {};
    fbo.flags = flags;
    fbo.width = width + 1;
    fbo.height = height + 1;
    
    glGenFramebuffers(1, &fbo.fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, fbo.fbo);
    
    GLenum colors[4] = {};
    u32 color_count = 0;
    
    if (flags & OPENGL_FBO_COLOR_OUT_0) {
        glGenTextures(1, &fbo.color_textures[0]);
        glBindTexture(GL_TEXTURE_2D, fbo.color_textures[0]);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
                     0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                               GL_TEXTURE_2D, fbo.color_textures[0], 0);
        colors[color_count++] = GL_COLOR_ATTACHMENT0;
    }
    
    if (flags & OPENGL_FBO_COLOR_OUT_1) {
        glGenTextures(1, &fbo.color_textures[1]);
        glBindTexture(GL_TEXTURE_2D, fbo.color_textures[1]);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
                     0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,
                               GL_TEXTURE_2D, fbo.color_textures[1], 0);
        colors[color_count++] = GL_COLOR_ATTACHMENT1;
    }
    
    if (flags & OPENGL_FBO_COLOR_OUT_2) {
        glGenTextures(1, &fbo.color_textures[2]);
        glBindTexture(GL_TEXTURE_2D, fbo.color_textures[2]);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
                     0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2,
                               GL_TEXTURE_2D, fbo.color_textures[2], 0);
        colors[color_count++] = GL_COLOR_ATTACHMENT2;
    }
    
    if (flags & OPENGL_FBO_COLOR_OUT_3) {
        glGenTextures(1, &fbo.color_textures[3]);
        glBindTexture(GL_TEXTURE_2D, fbo.color_textures[3]);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
                     0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3,
                               GL_TEXTURE_2D, fbo.color_textures[3], 0);
        colors[color_count++] = GL_COLOR_ATTACHMENT3;
    }
    
    if (flags & OPENGL_FBO_DEPTH_OUT) {
        glGenTextures(1, &fbo.depth_texture);
        glBindTexture(GL_TEXTURE_2D, fbo.depth_texture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height,
                     0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                               GL_TEXTURE_2D, fbo.depth_texture, 0);
    }
    
    glDrawBuffers(color_count, colors);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    
    return fbo;
}

internal void
opengl_clean_up_fbo(Opengl_Fbo* fbo) {
    glDeleteFramebuffers(1, &fbo->fbo);
    
    for (u32 texture_index = 0;
         texture_index < ARRAY_COUNT(fbo->color_textures);
         ++texture_index) {
        if (fbo->color_textures[texture_index]) {
            glDeleteTextures(1, &fbo->color_textures[texture_index]);
        }
    }
    
    if (fbo->depth_texture) {
        glDeleteTextures(1, &fbo->depth_texture);
    }
    
    fbo->fbo = 0;
}

internal void
opengl_force_fbo_size(Opengl_Fbo* fbo,
                      u32 width, u32 height,
                      u32 flags) {
    u32 adjusted_width = width + 1;
    u32 adjusted_height = height + 1;
    
    if ((fbo->width != adjusted_height) ||
        (fbo->height != adjusted_height)) {
        opengl_clean_up_fbo(fbo);
        *fbo = opengl_make_fbo(width, height, flags);
    }
}

internal void
use_program_begin(Opengl_Program_Common* prog) {
    glUseProgram(prog->prog_handle);
}

internal void
use_program_end(Opengl_Program_Common* prog) {
    glUseProgram(0);
}

internal void
free_program(Opengl_Program_Common* program) {
    glDeleteProgram(program->prog_handle);
    program->prog_handle = 0;
}

internal GLuint
opengl_create_program(char* defines, char* vertex_code,
                      char* fragment_code,
                      Opengl_Program_Io* inputs, umm input_count,
                      Opengl_Program_Io* outputs, umm output_count,
                      Opengl_Program_Common* result) {
    GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
    GLchar* vertex_shader_code[] = {defines, vertex_code};
    glShaderSource(vertex_shader_id, ARRAY_COUNT(vertex_shader_code),
                   vertex_shader_code, 0);
    glCompileShader(vertex_shader_id);
    
    GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);
    GLchar* fragment_shader_code[] = {defines, fragment_code};
    glShaderSource(fragment_shader_id, ARRAY_COUNT(fragment_shader_code),
                   fragment_shader_code, 0);
    glCompileShader(fragment_shader_id);
    
    GLuint program_id = glCreateProgram();
    glAttachShader(program_id, vertex_shader_id);
    glAttachShader(program_id, fragment_shader_id);
    
    // NOTE(yuval): Shader Inputs Specification
    for (umm input_index = 0; input_index < input_count; ++input_index) {
        glBindAttribLocation(program_id, inputs[input_index].index,
                             inputs[input_index].name);
    }
    
    // NOTE(yuval): Shader Output Specification
    for (umm output_index = 0; output_index < output_count; ++output_index) {
        glBindFragDataLocation(program_id, outputs[output_index].index,
                               outputs[output_index].name);
    }
    
    glLinkProgram(program_id);
    
    glValidateProgram(program_id);
    GLint linked = false;
    glGetProgramiv(program_id, GL_LINK_STATUS, &linked);
    
    if (!linked) {
        GLsizei ignored;
        char vertex_errors[4096];
        char fragment_errors[4096];
        char program_errors[4096];
        glGetShaderInfoLog(vertex_shader_id, sizeof(vertex_errors),
                           &ignored, vertex_errors);
        glGetShaderInfoLog(fragment_shader_id, sizeof(fragment_errors),
                           &ignored, fragment_errors);
        glGetProgramInfoLog(program_id, sizeof(program_errors),
                            &ignored, program_errors);
        
        ASSERT(!"Shader Validation Failed!");
    }
    
    glDeleteShader(vertex_shader_id);
    glDeleteShader(fragment_shader_id);
    
    result->prog_handle = program_id;
    
    return program_id;
}

internal void
compile_filled_rect_program(Opengl_Filled_Rect_Program* result) {
    char defines[1024];
    format_string(defines, sizeof(defines), "#version 330\n");
    
    char* vertex_code =
        "in vec3 vert_00;\n"
        "in vec3 vert_01;\n"
        "in vec3 vert_10;\n"
        "in vec3 vert_11;\n"
        "in vec4 vert_color00;\n"
        "in vec4 vert_color01;\n"
        "in vec4 vert_color10;\n"
        "in vec4 vert_color11;\n"
        "out vec4 rect_color;\n"
        "\n"
        "uniform mat4 view_projection;\n"
        "\n"
        "void main()\n"
        "{\n"
        "    vec3 vertices[] = vec3[](vert_00, vert_01, vert_10, vert_11);\n"
        "    vec4 world_space = vec4(vertices[gl_VertexID], 1);\n"
        "    vec4 clip_space = view_projection * world_space;\n"
        "    gl_Position = clip_space;\n"
        "    vec4 colors[] = vec4[](vert_color00, vert_color01, vert_color10, vert_color11);\n"
        "    rect_color = colors[gl_VertexID];\n"
        "}\n";
    
    char* fragment_code =
        "in vec4 rect_color;\n"
        "out vec4 color;\n"
        "void main()\n"
        "{\n"
        "    color = rect_color;\n"
        "}\n";
    
    Opengl_Program_Io inputs[] = {
        {7, "vert_color11"},
        {6, "vert_color10"},
        {5, "vert_color01"},
        {4, "vert_color00"},
        {3, "vert_11"},
        {2, "vert_10"},
        {1, "vert_01"},
        {0, "vert_00"}
    };
    
    Opengl_Program_Io outputs[] = {
        {0, "color"}
    };
    
    GLuint prog = opengl_create_program(defines, vertex_code,
                                        fragment_code,
                                        inputs, ARRAY_COUNT(inputs),
                                        outputs, ARRAY_COUNT(outputs),
                                        &result->common);
    
    result->view_projection =
        glGetUniformLocation(prog, "view_projection");
}

internal void
compile_fxaa_program(Opengl_Fxaa_Program* result) {
    char defines[1024];
    format_string(defines, sizeof(defines), "#version 330\n");
    
    char* vertex_code =
        "out vec2 v_rgbNW;\n"
        "out vec2 v_rgbNE;\n"
        "out vec2 v_rgbSW;\n"
        "out vec2 v_rgbSE;\n"
        "out vec2 v_rgbM;\n"
        "out vec2 frag_uv;\n"
        "\n"
        "uniform vec2 color_tex_resolution;\n"
        "\n"
        "void GetTexCoords(vec2 fragCoord, vec2 resolution,\n"
        "                  out vec2 v_rgbNW, out vec2 v_rgbNE,\n"
        "                  out vec2 v_rgbSW, out vec2 v_rgbSE,\n"
        "                  out vec2 v_rgbM)\n"
        "{\n"
        "	vec2 inverseVP = 1.0 / resolution.xy;\n"
        "	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n"
        "	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n"
        "	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n"
        "	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n"
        "	v_rgbM = vec2(fragCoord * inverseVP);\n"
        "    \n"
        "}\n"
        "\n"
        "void main()\n"
        "{\n"
        "    vec4 vertices[] = vec4[](vec4(0, 0, 0, 1),\n"
        "                             vec4(0, 1, 0, 1),\n"
        "                             vec4(1, 0, 0, 1),\n"
        "                             vec4(1, 1, 0, 1));\n"
        "    frag_uv = vertices[gl_VertexID].xy;\n"
        "    vec2 fragCoord = frag_uv * color_tex_resolution;\n"
        "    GetTexCoords(fragCoord, color_tex_resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
        "    gl_Position = (vertices[gl_VertexID] * 2 - 1);\n"
        "}\n";
    
    char* fragment_code =
        "in vec2 v_rgbNW;\n"
        "in vec2 v_rgbNE;\n"
        "in vec2 v_rgbSW;\n"
        "in vec2 v_rgbSE;\n"
        "in vec2 v_rgbM;\n"
        "in vec2 frag_uv;\n"
        "\n"
        "out vec4 color;\n"
        "\n"
        "uniform vec2 color_tex_resolution;\n"
        "uniform sampler2D color_tex;\n"
        "\n"
        "#define FXAA_REDUCE_MIN (1.0 / 128.0)\n"
        "#define FXAA_REDUCE_MUL (1.0 / 8.0)\n"
        "#define FXAA_SPAN_MAX   4.0\n"
        "\n"
        "vec4\n"
        "FXAA(sampler2D tex, vec2 frag_coord, vec2 resolution,\n"
        "     vec2 v_rgb_nw, vec2 v_rgb_ne, vec2 v_rgb_sw, vec2 v_rgb_se,\n"
        "     vec2 v_rgbM)\n"
        "{\n"
        "    vec4 color;\n"
        "    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
        "    vec3 rgb_nw = texture2D(tex, v_rgb_nw).xyz;\n"
        "    vec3 rgb_ne = texture2D(tex, v_rgb_ne).xyz;\n"
        "    vec3 rgb_sw = texture2D(tex, v_rgb_sw).xyz;\n"
        "    vec3 rgb_se = texture2D(tex, v_rgb_se).xyz;\n"
        "    vec4 texColor = texture2D(tex, v_rgbM);\n"
        "    vec3 rgbM  = texColor.xyz;\n"
        "    vec3 luma = vec3(0.299, 0.587, 0.114);\n"
        "    float lumaNW = dot(rgb_nw, luma);\n"
        "    float lumaNE = dot(rgb_ne, luma);\n"
        "    float lumaSW = dot(rgb_sw, luma);\n"
        "    float lumaSE = dot(rgb_se, luma);\n"
        "    float lumaM  = dot(rgbM,  luma);\n"
        "    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
        "    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
        "    \n"
        "    mediump vec2 dir;\n"
        "    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
        "    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
        "    \n"
        "    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
        "                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
        "    \n"
        "    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
        "    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
        "              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
        "                  dir * rcpDirMin)) * inverseVP;\n"
        "    \n"
        "    vec3 rgbA = 0.5 * (\n"
        "        texture2D(tex, frag_coord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
        "        texture2D(tex, frag_coord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
        "    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
        "        texture2D(tex, frag_coord * inverseVP + dir * -0.5).xyz +\n"
        "        texture2D(tex, frag_coord * inverseVP + dir * 0.5).xyz);\n"
        "    \n"
        "    float lumaB = dot(rgbB, luma);\n"
        "    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
        "        color = vec4(rgbA, texColor.a);\n"
        "    else\n"
        "        color = vec4(rgbB, texColor.a);\n"
        "    return color;\n"
        "}\n"
        "\n"
        "void main()\n"
        "{\n"
        "    vec2 fragCoord = frag_uv * color_tex_resolution; \n"
        "    color = FXAA(color_tex, fragCoord, color_tex_resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
        "}\n";
    
    Opengl_Program_Io outputs[] = {
        {0, "color"}
    };
    
    GLuint prog = opengl_create_program(defines, vertex_code,
                                        fragment_code,
                                        0, 0,
                                        outputs, ARRAY_COUNT(outputs),
                                        &result->common);
    
    result->color_tex = glGetUniformLocation(prog, "color_tex");
    result->color_tex_resolution =
        glGetUniformLocation(prog, "color_tex_resolution");
}

internal void
compile_world_program(Opengl_World_Program* result) {
    char defines[1024];
    format_string(defines, sizeof(defines), "#version 330\n");
    
    char* vertex_code =
        "out vec2 frag_uv;\n"
        "\n"
        "void main()\n"
        "{\n"
        "    vec4 vertices[] = vec4[](vec4(0, 0, 0, 1),\n"
        "                             vec4(0, 1, 0, 1),\n"
        "                             vec4(1, 0, 0, 1),\n"
        "                             vec4(1, 1, 0, 1));\n"
        "    frag_uv = vertices[gl_VertexID].xy;\n"
        "    gl_Position = (vertices[gl_VertexID] * 2 - 1);\n"
        "}\n";
    
    char* fragment_code =
        "in vec2 frag_uv;\n"
        "out vec4 color;\n"
        "uniform mat4 inverse_view_projection;\n"
        "uniform mat4 shadow_view_projection;\n"
        "uniform sampler2D albedo_texture;\n"
        "uniform sampler2D normal_texture;\n"
        "uniform sampler2D depth_texture;\n"
        "uniform sampler2DShadow shadow_map_texture;\n"
        "\n"
        "struct Light\n"
        "{\n"
        "    vec3 position;\n"
        "    vec3 color;\n"
        "    float radius;\n"
        "    float intensity;\n"
        "};\n"
        "uniform Light lights[16];\n"
        "uniform int light_count;\n"
        "\n"
        "void main()\n"
        "{\n"
        "    vec4 albedo = texture(albedo_texture, frag_uv);\n"
        "    vec4 normal = texture(normal_texture, frag_uv);\n"
        "    float depth = texture(depth_texture, frag_uv).r * 2 - 1;\n"
        "    \n"
        "    vec4 world_space_position;\n"
        "    {\n"
        "        vec4 camera_clip_space = vec4(frag_uv*2 - 1, depth, 1);\n"
        "        vec4 world_space = inverse_view_projection * camera_clip_space + vec4(normal.xyz, 0)*0.02;\n"
        "        world_space /= world_space.w;\n"
        "        world_space_position = world_space;\n"
        "    }\n"
        "    \n"
        "    float world_space_y_modifier = 1;\n"
        "    {\n"
        "        world_space_y_modifier = 1 - clamp(world_space_position.y, -15, 0) / -15;\n"
        "    }\n"
        "    \n"
        "    float depth_modifier = 1;\n"
        "    {\n"
        "    }\n"
        "    \n"
        "    vec3 point_light_modifier = vec3(0.1);\n"
        "    {\n"
        "        for(int i = 0; i < light_count; ++i)\n"
        "        {\n"
        "            vec3 fragment_to_light = lights[i].position - world_space_position.xyz;\n"
        "            float distance_squared = dot(fragment_to_light, fragment_to_light);\n"
        "            float radius_squared = lights[i].radius * lights[i].radius;\n"
        "            if(distance_squared < radius_squared)\n"
        "            {\n"
        "                float factor = clamp(1 - distance_squared/radius_squared, 0, 1);\n"
        "                factor *= (dot(normal.xyz, normalize(fragment_to_light)) + 1.f) / 2.f;\n"
        "                factor *= lights[i].intensity;\n"
        "                point_light_modifier += factor*lights[i].color;\n"
        "            }\n"
        "        }\n"
        "    }\n"
        "    \n"
        "    float shadow_modifier = 1;\n"
        "    {\n"
        "        vec4 shadow_clip_space = shadow_view_projection * world_space_position;\n"
        "        shadow_clip_space /= shadow_clip_space.w;\n"
        "        \n"
        "        float actual_depth = (shadow_clip_space.z+1)/2;\n"
        "        vec3 shadow_sample_pos = vec3((shadow_clip_space.xy + 1)/2, actual_depth);\n"
        "        float shadow_sample = (textureOffset(shadow_map_texture, shadow_sample_pos, ivec2(0, 0)) +\n"
        "                               textureOffset(shadow_map_texture, shadow_sample_pos, ivec2(-1, +0)) +\n"
        "                               textureOffset(shadow_map_texture, shadow_sample_pos, ivec2(+1, +0)) +\n"
        "                               textureOffset(shadow_map_texture, shadow_sample_pos, ivec2(+0, -1)) +\n"
        "                               textureOffset(shadow_map_texture, shadow_sample_pos, ivec2(+0, +1))) /\n"
        "            5.0;\n"
        "        shadow_modifier = shadow_sample/2 + 0.5;\n"
        "    }\n"
        "    \n"
        "    float diffuse_modifier = 1;\n"
        "    {\n"
        "        vec3 light_vector = normalize(vec3(1, 1, 1));\n"
        "        diffuse_modifier = (1+dot(normal.xyz, light_vector))/2;\n"
        "    }\n"
        "    \n"
        "    color = albedo;\n"
        "    color.rgb *= (point_light_modifier *\n"
        "                  shadow_modifier *\n"
        "                  diffuse_modifier *\n"
        "                  world_space_y_modifier *\n"
        "                  depth_modifier);\n"
        "}\n";
    
    Opengl_Program_Io outputs[] = {
        {0, "color"}
    };
    
    GLuint prog = opengl_create_program(defines, vertex_code,
                                        fragment_code,
                                        0, 0,
                                        outputs, ARRAY_COUNT(outputs),
                                        &result->common);
    
    result->inverse_view_projection =
        glGetUniformLocation(prog, "inverse_view_projection");
    result->shadow_view_projection =
        glGetUniformLocation(prog, "shadow_view_projection");
    result->albedo_texture = glGetUniformLocation(prog, "albedo_texture");
    result->normal_texture = glGetUniformLocation(prog, "normal_texture");
    result->depth_texture = glGetUniformLocation(prog, "depth_texture");
    result->shadow_map_texture =
        glGetUniformLocation(prog, "shadow_map_texture");
}

internal void
opengl_set_instanced_float_attribute_data(int index, int stride,
                                          int size, int offset) {
    glEnableVertexAttribArray(index);
    glVertexAttribPointer(index, size, GL_FLOAT, GL_FALSE, stride,
                          (void*)(sizeof(f32) * offset));
    glVertexAttribDivisor(index, 1);
}

internal void
opengl_init(Renderer_Opengl* opengl) {
    glDisable(GL_CULL_FACE);
    glEnable(GL_BLEND);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,
                        GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_DEPTH_TEST);
    
    glGenVertexArrays(1, &opengl->all_purpose_vao);
    
    // NOTE(yuval): Filled Rectangle Data Initialization
    glGenVertexArrays(1, &opengl->filled_rect_vao);
    glBindVertexArray(opengl->filled_rect_vao);
    
    glGenBuffers(1, &opengl->filled_rect_instance_buffer);
    glBindBuffer(GL_ARRAY_BUFFER, opengl->filled_rect_instance_buffer);
    glBufferData(GL_ARRAY_BUFFER, opengl->base.max_filled_rect_bytes,
                 0, GL_DYNAMIC_DRAW);
    opengl_set_instanced_float_attribute_data(
        0, sizeof(Renderer_Filled_Rect), 3, 0);
    opengl_set_instanced_float_attribute_data(
        1, sizeof(Renderer_Filled_Rect), 3, 3);
    opengl_set_instanced_float_attribute_data(
        2, sizeof(Renderer_Filled_Rect), 3, 6);
    opengl_set_instanced_float_attribute_data(
        3, sizeof(Renderer_Filled_Rect), 3, 9);
    opengl_set_instanced_float_attribute_data(
        4, sizeof(Renderer_Filled_Rect), 4, 12);
    opengl_set_instanced_float_attribute_data(
        5, sizeof(Renderer_Filled_Rect), 4, 16);
    opengl_set_instanced_float_attribute_data(
        6, sizeof(Renderer_Filled_Rect), 4, 20);
    opengl_set_instanced_float_attribute_data(
        7, sizeof(Renderer_Filled_Rect), 4, 24);
    glBindVertexArray(0);
    
    opengl->active_fbo = 0;
    opengl->main_fbo.w = 0;
    opengl->main_2d_fbo.w = 0;
    opengl->world_fbo.w = 0;
    opengl->screen_size_scratch_fbo.w = 0;
    
    compile_world_program(&opengl->world_program);
    compile_fxaa_program(&opengl->fxaa_program);
    compile_filled_rect_program(&opengl->filled_rect_program);
}

internal void
opengl_begin_frame(Renderer_Opengl* opengl,
                   f32 render_width, f32 render_height) {
    opengl->render_width = render_width;
    opengl->render_height = render_height;
    
    opengl->base.active_request.kind = Render_Request_Kind::NONE;
    opengl->base.request_count = 0;
    opengl->base.filled_rect_instance_data_alloc_pos = 0;
    
    opengl_force_fbo_size(&opengl->main_fbo,
                          (u32)render_width, (u32)render_height,
                          OPENGL_FBO_COLOR_OUT_0 |
                          OPENGL_FBO_DEPTH_OUT);
    
    opengl_force_fbo_size(&opengl->main_2d_fbo,
                          (u32)render_width, (u32)render_height,
                          OPENGL_FBO_COLOR_OUT_0 |
                          OPENGL_FBO_DEPTH_OUT);
    
    opengl_force_fbo_size(&opengl->world_fbo,
                          (u32)render_width, (u32)render_height,
                          OPENGL_FBO_COLOR_OUT_0 |
                          OPENGL_FBO_COLOR_OUT_1 |
                          OPENGL_FBO_DEPTH_OUT);
    
    opengl_force_fbo_size(&opengl->shadow_map_fbo,
                          1024, 1024,
                          OPENGL_FBO_DEPTH_OUT);
    
    opengl_force_fbo_size(&opengl->screen_size_scratch_fbo,
                          (u32)render_width, (u32)render_height,
                          OPENGL_FBO_COLOR_OUT_0);
}

internal void
opengl_end_frame(Renderer_Opengl* opengl) {
    Renderer* renderer = &opengl->base;
    
    renderer_finish_active_request(renderer);
    
    glDisable(GL_SCISSOR_TEST);
    glClearColor(0, 0, 1, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_SCISSOR_TEST);
    glViewport(0, 0, (GLsizei)opengl->render_width,
               (GLsizei)opengl->render_height);
    glScissor(0, 0, (GLsizei)opengl->render_width,
              (GLsizei)opengl->render_height);
    
    b32 world_enabled = false;
    b32 background_enable = false;
    Vector4 active_clip = {0, 0, opengl->render_width, opengl->render_height};
    
    Matrix4x4 identity_matrix = identity();
    
    Matrix4x4 projection_3d = identity_matrix;
    Matrix4x4 projection_2d = make_m4x4_orthographic(0, opengl->render_width,
                                                     opengl->render_height,
                                                     0, -100.0f, 100.0f);
    
    Matrix4x4 view = identity_matrix;
    Matrix4x4 view_3d = identity_matrix;
    Matrix4x4 projection = identity_matrix;
    Matrix4x4 view_projection = identity_matrix;
    Matrix4x4 inverse_view_projection;
    Matrix4x4 shadow_view;
    Matrix4x4 shadow_projection;
    Matrix4x4 shadow_view_projection;
    
    for (umm request_index = 0;
         request_index < renderer->request_count;
         ++request_index) {
        Render_Request* request = &renderer->requests[request_index];
        
        b32 additive = (request->flags & Render_Flags::ADDITIVE_BLEND);
        
        if (request->flags & Render_Flags::RENDER_2D) {
            view = identity_matrix;
            view_projection = projection = projection_2d;
            
            opengl_bind_fbo(opengl, &opengl->main_2d_fbo);
            
            glDisable(GL_DEPTH_TEST);
            glDepthMask(GL_FALSE);
        } else {
            view = view_3d;
            projection = projection_3d;
            
            opengl_bind_fbo(opengl, &opengl->world_fbo);
            
            glEnable(GL_DEPTH_TEST);
            glDepthMask((request->flags & Render_Flags::NO_DEPTH_WRITE) ?
                        GL_FALSE : GL_TRUE);
            
        }
        
        switch (request->kind) {
            case Render_Request_Kind::FILLED_RECT: {
                // NOTE(yuval): Data Upload
                glBindBuffer(GL_ARRAY_BUFFER,
                             opengl->filled_rect_instance_buffer);
                glBufferSubData(GL_ARRAY_BUFFER, 0, request->data_size,
                                (GLubyte*)renderer->filled_rect_instance_data +
                                request->data_offset);
                glBindBuffer(GL_ARRAY_BUFFER, 0);
                
                // NOTE(yuval): Filled Rect Rendering
                use_program_begin(&opengl->filled_rect_program.common);
                glBindVertexArray(opengl->filled_rect_vao);
                
                glUniformMatrix4fv(
                    opengl->filled_rect_program.view_projection,
                    1, GL_FALSE,
                    &view_projection.e[0][0]);
                
                GLint first = 0;
                GLsizei count = 4;
                GLsizei instance_count = (GLsizei)
                    (request->data_size / sizeof(Renderer_Filled_Rect));
                glDrawArraysInstanced(GL_TRIANGLE_STRIP, first,
                                      count, instance_count);
                
                use_program_end(&opengl->filled_rect_program.common);
                
                glBindVertexArray(0);
            } break;
        }
    }
    
#if 1
    // NOTE(yuval): Render world to main framebuffer
    opengl_bind_fbo(opengl, &opengl->main_fbo);
    glDepthMask(GL_TRUE);
    
    use_program_begin(&opengl->world_program.common);
    glBindVertexArray(opengl->all_purpose_vao);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, opengl->world_fbo.color_textures[0]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, opengl->world_fbo.color_textures[1]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_2D, opengl->world_fbo.depth_texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    glActiveTexture(GL_TEXTURE3);
    glBindTexture(GL_TEXTURE_2D, opengl->shadow_map_fbo.depth_texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE,
                    GL_COMPARE_REF_TO_TEXTURE);
    
    glUniformMatrix4fv(opengl->world_program.inverse_view_projection,
                       1, GL_FALSE,
                       &inverse_view_projection.e[0][0]);
    
    glUniformMatrix4fv(opengl->world_program.shadow_view_projection,
                       1, GL_FALSE,
                       &shadow_view_projection.e[0][0]);
    
    glUniform1i(opengl->world_program.albedo_texture, 0);
    glUniform1i(opengl->world_program.normal_texture, 1);
    glUniform1i(opengl->world_program.depth_texture, 2);
    glUniform1i(opengl->world_program.shadow_map_texture, 3);
    
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    
    glBindVertexArray(0);
    use_program_end(&opengl->world_program.common);
#endif // #if 1
    
#if 1
    // NOTE(yuval): Do FXAA pass on main framebuffer to default framebuffer
    opengl_bind_fbo(opengl, 0);
    glDepthMask(GL_TRUE);
    
    use_program_begin(&opengl->fxaa_program.common);
    glBindVertexArray(opengl->all_purpose_vao);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, opengl->main_fbo.color_textures[0]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glUniform1i(opengl->fxaa_program.color_tex, 0);
    glUniform2f(opengl->fxaa_program.color_tex_resolution,
                opengl->render_width, opengl->render_height);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    
    glBindVertexArray(0);
    use_program_end(&opengl->fxaa_program.common);
#endif // #if 1
    
#if 1
    // NOTE(yuval): Do FXAA pass on main 2d framebuffer to default framebuffer
    opengl_bind_fbo(opengl, 0);
    glDepthMask(GL_TRUE);
    
    use_program_begin(&opengl->fxaa_program.common);
    glBindVertexArray(opengl->all_purpose_vao);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, opengl->main_2d_fbo.color_textures[0]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glUniform1i(opengl->fxaa_program.color_tex, 0);
    glUniform2f(opengl->fxaa_program.color_tex_resolution,
                opengl->render_width, opengl->render_height);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    
    glBindVertexArray(0);
    use_program_end(&opengl->fxaa_program.common);
#endif // #if 1
    
    GLenum error = glGetError();
    if (error) {
        if (error & GL_INVALID_ENUM) {
            ASSERT(!"Invalid Enum");
        }
        
        if (error & GL_INVALID_VALUE) {
            ASSERT(!"Invalid Value");
        }
        
        if (error & GL_INVALID_OPERATION) {
            ASSERT(!"Invalid Operation");
        }
        
        if (error & GL_STACK_UNDERFLOW) {
            ASSERT(!"Stack Underflow");
        }
        
        if (error & GL_STACK_OVERFLOW) {
            ASSERT(!"Stack Underflow");
        }
        
        ASSERT(!"Out of memory");
    }
}
