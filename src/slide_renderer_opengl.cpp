#define GL_NUM_EXTENSIONS                 0x821D

#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D

#define GL_TEXTURE_3D                     0x806F

#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7

#define GL_DEBUG_SEVERITY_HIGH            0x9146
#define GL_DEBUG_SEVERITY_MEDIUM          0x9147
#define GL_DEBUG_SEVERITY_LOW             0x9148
#define GL_DEBUG_TYPE_MARKER              0x8268
#define GL_DEBUG_TYPE_PUSH_GROUP          0x8269
#define GL_DEBUG_TYPE_POP_GROUP           0x826A
#define GL_DEBUG_SEVERITY_NOTIFICATION    0x826B

#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA

#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D

#define GL_FRAMEBUFFER_SRGB               0x8DB9
#define GL_SRGB8_ALPHA8                   0x8C43

#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83

#define GL_TEXTURE_2D_ARRAY               0x8C1A

#define GL_FRAMEBUFFER                    0x8D40
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5

#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_DEPTH_COMPONENT32F             0x8CAC

#define GL_RED_INTEGER                    0x8D94
#define GL_GREEN_INTEGER                  0x8D95
#define GL_BLUE_INTEGER                   0x8D96

#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C

#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_MAX_SAMPLES                    0x8D57
#define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F

#define OPENGL_DEPTH_COMPONENT_KIND GL_DEPTH_COMPONENT32F

global GLenum opengl_all_color_attachments[] = {
    GL_COLOR_ATTACHMENT0,
    GL_COLOR_ATTACHMENT1,
    GL_COLOR_ATTACHMENT2,
    GL_COLOR_ATTACHMENT3,
    GL_COLOR_ATTACHMENT4,
    GL_COLOR_ATTACHMENT5,
    GL_COLOR_ATTACHMENT6,
    GL_COLOR_ATTACHMENT7,
    GL_COLOR_ATTACHMENT8,
    GL_COLOR_ATTACHMENT9,
    GL_COLOR_ATTACHMENT10,
    GL_COLOR_ATTACHMENT11,
    GL_COLOR_ATTACHMENT12,
    GL_COLOR_ATTACHMENT13,
    GL_COLOR_ATTACHMENT14,
    GL_COLOR_ATTACHMENT15,
    GL_COLOR_ATTACHMENT16,
    GL_COLOR_ATTACHMENT17,
    GL_COLOR_ATTACHMENT18,
    GL_COLOR_ATTACHMENT19,
    GL_COLOR_ATTACHMENT20,
    GL_COLOR_ATTACHMENT21,
    GL_COLOR_ATTACHMENT22,
    GL_COLOR_ATTACHMENT23,
    GL_COLOR_ATTACHMENT24,
    GL_COLOR_ATTACHMENT25,
    GL_COLOR_ATTACHMENT26,
    GL_COLOR_ATTACHMENT27,
    GL_COLOR_ATTACHMENT28,
    GL_COLOR_ATTACHMENT29,
    GL_COLOR_ATTACHMENT30,
    GL_COLOR_ATTACHMENT31,
};

global char* global_shader_header_code = R"FOO(
#define m4x4 mat4x4
#define f32 float
#define s32 int
#define u32 int unsigned
#define v4 vec4
#define v3 vec3
#define v2 vec2
#define V4 vec4
#define V3 vec3
#define V2 vec2
#define Lerp(a, t, b) mix(a, b, t)
#define Clamp01(t) clamp(t, 0, 1)
#define Clamp(min, t, max) clamp(t, min, max)
#define Inner(a, b) dot(a, b)
#define Length(a) length(a)
#define LengthSq(a) dot(a, a)
#define SquareRoot(a) sqrt(a)
#define MaxLightIntensity 10

f32 Clamp01MapToRange(f32 Min, f32 t, f32 Max)
{
f32 Range = Max - Min;
f32 Result = Clamp01((t - Min) / Range);

return(Result);
}

v2 PackNormal2(v2 N)
{
v2 Result;
Result.x = 0.5f + 0.5f*N.x;
Result.y = 0.5f + 0.5f*N.y;
return(Result);
}

v2 UnpackNormal2(v2 N)
{
v2 Result;
Result.x = -1.0f + 2.0f*N.x;
Result.y = -1.0f + 2.0f*N.y;
return(Result);
}

v3 ExtendNormalZ(v2 N)
{
v3 Result = V3(N, sqrt(1 - N.x*N.x - N.y*N.y));
return(Result);
}

v3 UnpackNormal3(v2 N)
{
v3 Result = ExtendNormalZ(UnpackNormal2(N));
return(Result);
}

)FOO";

internal Opengl_Info
opengl_get_info(b32 is_modern_context) {
    Opengl_Info result = {};
    
    result.modern_context = is_modern_context;
    result.vendor = (char*)glGetString(GL_VENDOR);
    result.renderer = (char*)glGetString(GL_RENDERER);
    result.version = (char*)glGetString(GL_VERSION);
    
    if (result.modern_context) {
        result.shading_language_version =
            (char*)glGetString(GL_SHADING_LANGUAGE_VERSION);
    } else {
        result.shading_language_version = "(none)";
    }
    
    if (glGetStringi) {
        GLint extension_count = 0;
        glGetIntegerv(GL_NUM_EXTENSIONS, &extension_count);
        
        for (GLint extension_index = 0;
             extension_index < extension_count;
             ++extension_index) {
            char* ext_name = (char*)glGetStringi(GL_EXTENSIONS,
                                                 extension_index);
            
            if (strings_match(ext_name, "GL_EXT_texture_sRGB")) {
                result.opengl_ext_texture_srgb = true;
            } else if (strings_match(ext_name, "GL_EXT_framebuffer_sRGB")) {
                result.opengl_ext_framebuffer_srgb = true;
            } else if (strings_match(ext_name, "GL_ARB_framebuffer_sRGB")) {
                result.opengl_ext_framebuffer_srgb = true;
            } else if (strings_match(ext_name, "GL_ARB_framebuffer_object")) {
                result.opengl_arb_framebuffer_object = true;
            }
        }
    }
    
    char* major_at = result.version;
    char* minor_at = 0;
    for (char* at = result.version; *at; ++at) {
        if (at[0] == '.') {
            minor_at = at + 1;
            break;
        }
    }
    
    s32 major = 1;
    s32 minor = 1;
    if (minor_at) {
        major = to_s32(major_at);
        minor = to_s32(minor_at);
    }
    
    if ((major > 2 ) || ((major == 2) && (minor >= 1))) {
        result.opengl_ext_texture_srgb = true;
    }
    
    return result;
}

internal b32
is_valid_array(GLuint index) {
    b32 result = (index != -1);
    return result;
}

internal void
use_program_begin(Opengl_Program_Common* prog) {
    glUseProgram(prog->prog_handle);
    
    GLuint p_array = prog->vert_p_id;
    GLuint n_array = prog->vert_n_id;
    GLuint uv_array = prog->vert_uv_id;
    GLuint c_array = prog->vert_color_id;
    GLuint light_index = prog->vert_light_index;
    GLuint texture_index = prog->vert_texture_index;
    
    if (is_valid_array(p_array)) {
        glEnableVertexAttribArray(p_array);
        glVertexAttribPointer(p_array, 4, GL_FLOAT, false,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, p));
    }
    
    if (is_valid_array(n_array)) {
        glEnableVertexAttribArray(n_array);
        glVertexAttribPointer(n_array, 3, GL_FLOAT, false,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, n));
    }
    
    if (is_valid_array(uv_array)) {
        glEnableVertexAttribArray(uv_array);
        glVertexAttribPointer(uv_array, 2, GL_FLOAT, false,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, uv));
    }
    
    if (is_valid_array(c_array)) {
        glEnableVertexAttribArray(c_array);
        glVertexAttribPointer(c_array, 4, GL_UNSIGNED_BYTE, true,
                              sizeof(Textured_Vertex),
                              (void*)OFFSET_OF(Textured_Vertex, color));
    }
    
    if (is_valid_array(light_index)) {
        glEnableVertexAttribArray(light_index);
        glVertexAttribIPointer(light_index, 1, GL_UNSIGNED_SHORT,
                               sizeof(Textured_Vertex),
                               (void*)OFFSET_OF(Textured_Vertex, light_index));
    }
    
    if (is_valid_array(texture_index)) {
        glEnableVertexAttribArray(texture_index);
        glVertexAttribIPointer(texture_index, 1, GL_UNSIGNED_SHORT,
                               sizeof(Textured_Vertex),
                               (void*)OFFSET_OF(Textured_Vertex, texture_index));
    }
    
    for (u32 sampler_index = 0;
         sampler_index < prog->sampler_count;
         ++sampler_index) {
        glUniform1i(prog->samplers[sampler_index], sampler_index);
    }
}

internal void
use_program_begin(Z_Bias_Program* prog, Render_Setup* setup,
                  f32 alpha_threshold) {
    use_program_begin(&prog->common);
    
    glUniformMatrix4fv(prog->transform_id, 1, GL_TRUE, setup->proj.e[0]);
    glUniform3fv(prog->camera_p, 1, setup->camera_p.e);
    glUniform3fv(prog->fog_direction, 1, setup->fog_direction.e);
    glUniform3fv(prog->fog_color, 1, setup->fog_color.e);
    glUniform1f(prog->fog_start_distance, setup->fog_start_distance);
    glUniform1f(prog->fog_end_distance, setup->fog_end_distance);
    glUniform1f(prog->clip_alpha_start_distance,
                setup->clip_alpha_start_distance);
    glUniform1f(prog->clip_alpha_end_distance,
                setup->clip_alpha_end_distance);
    glUniform1f(prog->alpha_threshold, alpha_threshold);
}

internal void
use_program_end(Opengl_Program_Common* prog) {
    glUseProgram(0);
    
    GLuint p_array = prog->vert_p_id;
    GLuint n_array = prog->vert_n_id;
    GLuint uv_array = prog->vert_uv_id;
    GLuint c_array = prog->vert_color_id;
    GLuint light_index = prog->vert_light_index;
    GLuint texture_index = prog->vert_texture_index;
    
    if (is_valid_array(p_array)) {
        glDisableVertexAttribArray(p_array);
    }
    
    if (is_valid_array(n_array)) {
        glDisableVertexAttribArray(n_array);
    }
    
    if (is_valid_array(uv_array)) {
        glDisableVertexAttribArray(uv_array);
    }
    
    if (is_valid_array(c_array)) {
        glDisableVertexAttribArray(c_array);
    }
    
    if (is_valid_array(light_index)) {
        glDisableVertexAttribArray(light_index);
    }
    
    if (is_valid_array(texture_index)) {
        glDisableVertexAttribArray(texture_index);
    }
}

internal GLuint
get_special_texture_handle_for(Opengl* opengl, Renderer_Texture texture) {
    u32 index = texture_index_from(texture);
    ASSERT(index < opengl->max_special_texture_count);
    
    GLuint result = opengl->special_texture_handles[index];
    return result;
}

internal void
opengl_manage_textures(Opengl* opengl, Renderer_Texture_Queue* queue) {
    while (queue->op_count) {
        Texture_Op* op = &queue->ops[queue->first_op_index];
        if (op->state == Texture_Op_State::PENDING_LOAD) {
            break;
        } else if (op->state == Texture_Op_State::READY_TO_TRANSFER) {
            Renderer_Texture texture = op->texture;
            void* data = op->data;
            
            if (is_special_texture(texture)) {
                GLuint handle =
                    get_special_texture_handle_for(opengl, texture);
                
                glBindTexture(GL_TEXTURE_2D_ARRAY, handle);
                glTexImage3D(GL_TEXTURE_2D_ARRAY, 0,
                             opengl->default_sprite_texture_format,
                             texture.width, texture.height, 1, 0,
                             GL_BGRA_EXT, GL_UNSIGNED_BYTE, data);
            } else {
                u32 texture_index = texture_index_from(texture);
                ASSERT(texture_index < opengl->max_texture_count);
                
                glBindTexture(GL_TEXTURE_2D_ARRAY, opengl->texture_array);
                glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, 0, 0,
                                texture_index, texture.width,
                                texture.height, 1, GL_BGRA_EXT,
                                GL_UNSIGNED_BYTE, data);
            }
            
            glBindTexture(GL_TEXTURE_2D, 0);
        } else {
            ASSERT(op->state == Texture_Op_State::EMPTY);
        }
        
        queue->transfer_memory_first_used = op->transfer_memory_last_used;
        
        --queue->op_count;
        ++queue->first_op_index;
        if (queue->first_op_index >= ARRAY_COUNT(queue->ops)) {
            queue->first_op_index = 0;
        }
    }
}

internal void
opengl_link_samplers(Opengl_Program_Common *prog,
                     char* sampler_0 = 0,
                     char* sampler_1 = 0,
                     char* sampler_2 = 0,
                     char* sampler_3 = 0,
                     char* sampler_4 = 0,
                     char* sampler_5 = 0,
                     char* sampler_6 = 0,
                     char* sampler_7 = 0,
                     char* sampler_8 = 0,
                     char* sampler_9 = 0,
                     char* sampler_10 = 0,
                     char* sampler_11 = 0,
                     char* sampler_12 = 0,
                     char* sampler_13 = 0,
                     char* sampler_14 = 0,
                     char* sampler_15 = 0) {
    char* sampler_names[] = {
        sampler_0, sampler_1, sampler_2,
        sampler_3, sampler_4, sampler_5,
        sampler_6, sampler_7, sampler_8,
        sampler_9, sampler_10, sampler_11,
        sampler_12, sampler_13, sampler_14,
        sampler_15
    };
    
    for (u32 sampler_index = 0;
         sampler_index < ARRAY_COUNT(sampler_names);
         ++sampler_index) {
        char* name = sampler_names[sampler_index];
        
        if (name) {
            GLuint sampler_id = glGetUniformLocation(prog->prog_handle,
                                                     name);
            ASSERT(prog->sampler_count < ARRAY_COUNT(prog->samplers));
            prog->samplers[prog->sampler_count++] = sampler_id;
        }
    }
}

internal void
free_program(Opengl_Program_Common* program) {
    glDeleteProgram(program->prog_handle);
    program->prog_handle = 0;
}

internal GLuint
opengl_create_program(char* defines, char* header_code,
                      char* vertex_code, char* fragment_code,
                      Opengl_Program_Common* result) {
    GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);
    GLchar* vertex_shader_code[] = {defines, header_code, vertex_code};
    glShaderSource(vertex_shader_id, ARRAY_COUNT(vertex_shader_code),
                   vertex_shader_code, 0);
    glCompileShader(vertex_shader_id);
    
    GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);
    GLchar* fragment_shader_code[] = {defines, header_code, fragment_code};
    glShaderSource(fragment_shader_id, ARRAY_COUNT(fragment_shader_code),
                   fragment_shader_code, 0);
    glCompileShader(fragment_shader_id);
    
    GLuint program_id = glCreateProgram();
    glAttachShader(program_id, vertex_shader_id);
    glAttachShader(program_id, fragment_shader_id);
    glLinkProgram(program_id);
    
    glValidateProgram(program_id);
    GLint linked = false;
    glGetProgramiv(program_id, GL_LINK_STATUS, &linked);
    
    if (!linked) {
        GLsizei ignored;
        char vertex_errors[4096];
        char fragment_errors[4096];
        char program_errors[4096];
        glGetShaderInfoLog(vertex_shader_id, sizeof(vertex_errors),
                           &ignored, vertex_errors);
        glGetShaderInfoLog(fragment_shader_id, sizeof(fragment_errors),
                           &ignored, fragment_errors);
        glGetProgramInfoLog(program_id, sizeof(program_errors),
                            &ignored, program_errors);
        
        ASSERT(!"Shader Validation Failed!");
    }
    
    glDeleteShader(vertex_shader_id);
    glDeleteShader(fragment_shader_id);
    
    result->prog_handle = program_id;
    result->vert_p_id = glGetAttribLocation(program_id, "VertP");
    result->vert_n_id = glGetAttribLocation(program_id, "VertN");
    result->vert_uv_id = glGetAttribLocation(program_id, "VertUV");
    result->vert_color_id = glGetAttribLocation(program_id, "VertColor");
    result->vert_light_index =
        glGetAttribLocation(program_id, "VertLightIndex");
    result->vert_texture_index =
        glGetAttribLocation(program_id, "VertTextureIndex");
    result->sampler_count = 0;
    
    return program_id;
}

internal void
compile_final_stretch(Opengl* opengl, Opengl_Program_Common* result) {
    char defines[1024];
    format_string(defines, sizeof(defines),
                  "#version 330\n"
                  "#define ShaderSimTexWriteSRGB %d\n"
                  "#define ShaderSimTexReadSRGB %d\n",
                  opengl->shader_sim_tex_write_srgb,
                  opengl->shader_sim_tex_read_srgb);
    
    char* vertex_code = R"FOO(
    // Vertex code
    in v4 VertP;
    in v2 VertUV;
    
    smooth out v2 FragUV;
    
    void main(void)
    {
    gl_Position = VertP;
    FragUV = VertUV;
    }
    )FOO";
    
    char* fragment_code = R"FOO(
    // Fragment code
    uniform sampler2D Image;
    
    smooth in vec2 FragUV;
    
    out vec4 BlendUnitColor;
    
    void main(void)
    {
    BlendUnitColor = texture(Image, FragUV);
    }
    )FOO";
    
    GLuint prog = opengl_create_program(defines,
                                        global_shader_header_code,
                                        vertex_code, fragment_code,
                                        result);
    opengl_link_samplers(result, "Image");
}

internal void
compile_peel_composite(Opengl* opengl, Opengl_Program_Common* result) {
    char defines[1024];
    format_string(defines, sizeof(defines),
                  "#version 330\n"
                  "#define ShaderSimTexWriteSRGB %d\n"
                  "#define ShaderSimTexReadSRGB %d\n"
                  "#define DepthPeel %d\n",
                  opengl->shader_sim_tex_write_srgb,
                  opengl->shader_sim_tex_read_srgb,
                  false);
    
    char* vertex_code = R"FOO(
    // Vertex code
    in v4 VertP;
    in v4 VertColor;
    in v2 VertUV;
    smooth out v2 FragUV;
    smooth out v4 FragColor;
    void main(void)
    {
    gl_Position = VertP;
    FragUV = VertUV;
    FragColor = VertColor;
    }
    )FOO";
    
    char* fragment_code = R"FOO(
    // Fragment code
    uniform sampler2D Peel0Sampler;
    uniform sampler2D Peel1Sampler;
    uniform sampler2D Peel2Sampler;
    uniform sampler2D Peel3Sampler;
    
    smooth in vec2 FragUV;
    smooth in vec4 FragColor;
    
    out vec4 BlendUnitColor;
    
    void main(void)
    {
    vec4 Peel0 = texture(Peel0Sampler, FragUV);
    vec4 Peel1 = texture(Peel1Sampler, FragUV);
    vec4 Peel2 = texture(Peel2Sampler, FragUV);
    vec4 Peel3 = texture(Peel3Sampler, FragUV);
    
    #if ShaderSimTexReadSRGB
    Peel0.rgb *= Peel0.rgb;
    Peel1.rgb *= Peel1.rgb;
    Peel2.rgb *= Peel2.rgb;
    Peel3.rgb *= Peel3.rgb;
    #endif
    
    #if 0
    Peel3.rgb *= (1.0f / Peel3.a);
    #endif
    
    #if 0
    Peel0.rgb = Peel0.a*V3(0, 0, 1);
    Peel1.rgb = Peel1.a*V3(0, 1, 0);
    Peel2.rgb = Peel2.a*V3(1, 0, 0);
    Peel3.rgb = V3(0, 0, 0);
    #endif
    
    BlendUnitColor.rgb = Peel3.rgb;
    BlendUnitColor.rgb = Peel2.rgb + (1 - Peel2.a)*BlendUnitColor.rgb;
    BlendUnitColor.rgb = Peel1.rgb + (1 - Peel1.a)*BlendUnitColor.rgb;
    BlendUnitColor.rgb = Peel0.rgb + (1 - Peel0.a)*BlendUnitColor.rgb;
    
    #if ShaderSimTexWriteSRGB
    BlendUnitColor.rgb = sqrt(BlendUnitColor.rgb);
    #endif
    }
    )FOO";
    
    GLuint prog = opengl_create_program(defines,
                                        global_shader_header_code,
                                        vertex_code, fragment_code,
                                        result);
    opengl_link_samplers(result, "Peel0Sampler", "Peel1Sampler",
                         "Peel2Sampler", "Peel3Sampler");
}

internal void
compile_z_bias_program(Opengl* opengl, Z_Bias_Program* result,
                       b32 depth_peel, b32 lighting_disabled) {
    char defines[1024];
    format_string(defines, sizeof(defines),
                  "#version 330\n"
                  "#define ShaderSimTexWriteSRGB %d\n"
                  "#define ShaderSimTexReadSRGB %d\n"
                  "#define DepthPeel %d\n"
                  "#define LIGHTING_DISABLED %d\n",
                  opengl->shader_sim_tex_write_srgb,
                  opengl->shader_sim_tex_read_srgb,
                  depth_peel,
                  lighting_disabled);
    
    char* vertex_code = R"FOO(
    // Vertex code
    uniform m4x4 Transform;
    
    uniform v3 CameraP;
    uniform v3 FogDirection;
    
    in v4 VertP;
    in v3 VertN;
    in v2 VertUV;
    in v4 VertColor;
    in int VertLightIndex;
    in int VertTextureIndex;
    
    smooth out v2 FragUV;
    smooth out v4 FragColor;
    smooth out f32 FogDistance;
    smooth out v3 WorldP;
    smooth out v3 WorldN;
    
    flat out int FragLightIndex;
    flat out int FragTextureIndex;
    
    void main(void)
    {
    v4 InVertex = V4(VertP.xyz, 1.0);
    f32 ZBias = VertP.w;
    
    v4 ZVertex = InVertex;
    ZVertex.z += ZBias;
    
    v4 ZMinTransform = Transform*InVertex;
    v4 ZMaxTransform = Transform*ZVertex;
    
    f32 ModifiedZ = (ZMinTransform.w / ZMaxTransform.w)*ZMaxTransform.z;
    
    gl_Position = vec4(ZMinTransform.x, ZMinTransform.y, ModifiedZ, ZMinTransform.w);
    
    FragUV = VertUV.xy;
    FragColor = VertColor;
    
    FogDistance = Inner(ZVertex.xyz - CameraP, FogDirection);
    WorldP = ZVertex.xyz;
    WorldN = VertN;
    
    FragLightIndex = VertLightIndex;
    FragTextureIndex = VertTextureIndex;
    }
    )FOO";
    
    char* fragment_code = R"FOO(
    // Fragment code
    
    //uniform v4 FogColor;
    uniform sampler2DArray TextureSampler;
    #if DepthPeel
    uniform sampler2D DepthSampler;
    #endif
    uniform v3 FogColor;
    uniform f32 AlphaThreshold;
    uniform f32 FogStartDistance;
    uniform f32 FogEndDistance;
    uniform f32 ClipAlphaStartDistance;
    uniform f32 ClipAlphaEndDistance;
    uniform v3 CameraP;
    
    uniform sampler1D Light0Sampler;
    uniform sampler1D Light1Sampler;
    
    smooth in vec2 FragUV;
    smooth in vec4 FragColor;
    smooth in f32 FogDistance;
    smooth in vec3 WorldP;
    smooth in vec3 WorldN;
    
    flat in int FragLightIndex;
    flat in int FragTextureIndex;
    
    out v4 BlendUnitColor;
    
    v4 RunningSum;
    void FetchAndSum(int LightI)
    {
    v4 LightData0 = texelFetch(Light0Sampler, LightI, 0);
    v4 LightData1 = texelFetch(Light1Sampler, LightI, 0);
    
    v3 LightP = LightData0.xyz;
    v3 LightC = LightData1.rgb;
    v3 LightD;
    LightD.x = LightData0.a;
    LightD.y = LightData1.a;
    LightD.z = SquareRoot(1.0f - (LightD.x*LightD.x + LightD.y*LightD.y));
    if(LightC.r < 0)
    {
    LightC.r = -LightC.r;
    LightD.z = -LightD.z;
    }
    
    f32 Contrib = 1.0f / (1.0f + LengthSq(LightP - WorldP));
    f32 DirFalloff = Clamp01(Inner(LightD.rgb, WorldN));
    
    RunningSum.rgb += Contrib*DirFalloff*LightC.rgb;
    RunningSum.a += Contrib;
    }
    
    v3 SumLight()
    {
    RunningSum = V4(0, 0, 0, 0);
    
    FetchAndSum(FragLightIndex + 0);
    FetchAndSum(FragLightIndex + 1);
    FetchAndSum(FragLightIndex + 2);
    FetchAndSum(FragLightIndex + 3);
    
    v4 Result = RunningSum;
    
    if(Result.a > 0.0f)
    {
    Result.rgb *= 1.0f/Result.a;
    }
    
    return(Result.rgb);
    }
    
    void main(void)
    {
    #if DepthPeel
    f32 ClipDepth = texelFetch(DepthSampler, ivec2(gl_FragCoord.xy), 0).r;
    if(gl_FragCoord.z <= ClipDepth)
    {
    discard;
    }
    #endif
    
    vec3 ArrayUV = vec3(FragUV.x, FragUV.y, f32(FragTextureIndex));
    vec4 TexSample = texture(TextureSampler, ArrayUV);
    #if ShaderSimTexReadSRGB
    TexSample.rgb *= TexSample.rgb;
    #endif
    
    f32 FogAmount = Clamp01MapToRange(FogStartDistance, FogDistance, FogEndDistance);
    f32 AlphaAmount = Clamp01MapToRange(ClipAlphaStartDistance, FogDistance, ClipAlphaEndDistance);
    v4 ModColor = AlphaAmount*FragColor*TexSample;
    if(ModColor.a > AlphaThreshold)
    {
    v3 SurfaceReflect = ModColor.rgb;
    
    #if LIGHTING_DISABLED
    #else
    if(FragLightIndex != 0)
    {
    v3 L = SumLight();
    SurfaceReflect *= L;
    }
    #endif
    
    SurfaceReflect.rgb = Lerp(SurfaceReflect.rgb, FogAmount, FogColor.rgb*ModColor.a);
    SurfaceReflect.r = Clamp01(SurfaceReflect.r);
    SurfaceReflect.g = Clamp01(SurfaceReflect.g);
    SurfaceReflect.b = Clamp01(SurfaceReflect.b);
    
    #if ShaderSimTexWriteSRGB
    SurfaceReflect = sqrt(SurfaceReflect.rgb);
    #endif
    
    BlendUnitColor.rgb = SurfaceReflect;
    BlendUnitColor.a = ModColor.a;
    }
    else
    {
    discard;
    }
    }
    )FOO";
    
    GLuint prog = opengl_create_program(
        defines, global_shader_header_code,
        vertex_code, fragment_code, &result->common);
    opengl_link_samplers(&result->common, "TextureSampler",
                         "DepthSampler", "Light0Sampler",
                         "Light1Sampler");
    
    result->transform_id = glGetUniformLocation(prog, "Transform");
    result->camera_p = glGetUniformLocation(prog, "CameraP");
    result->fog_direction = glGetUniformLocation(prog, "FogDirection");
    result->fog_color = glGetUniformLocation(prog, "FogColor");
    result->fog_start_distance =
        glGetUniformLocation(prog, "FogStartDistance");
    result->fog_end_distance = glGetUniformLocation(prog, "FogEndDistance");
    result->clip_alpha_start_distance =
        glGetUniformLocation(prog, "ClipAlphaStartDistance");
    result->clip_alpha_end_distance = glGetUniformLocation(prog, "ClipAlphaEndDistance");
    result->alpha_threshold = glGetUniformLocation(prog, "AlphaThreshold");
}

/*
internal Opengl_Framebuffer*
get_depth_peel_read_buffer(Opengl* opengl, u32 index) {
Opengl_Framebuffer* peel_buffer = opengl->depth_peel_buffer + index;

if (opengl->multisampling) {
peel_buffer = opengl->depth_peek
}
}
*/

internal GLuint
framebuffer_tex_image(Opengl* opengl, GLuint slot,
                      u32 width, u32 height,
                      GLint filter_kind, GLuint format) {
    GLuint result = 0;
    
    glGenTextures(1, &result);
    glBindTexture(slot, result);
    
    if (slot == GL_TEXTURE_2D_MULTISAMPLE) {
        glTexImage2DMultisample(slot, opengl->max_multisample_count,
                                format, width, height, GL_FALSE);
    } else {
        glTexImage2D(slot, 0, format, width, height, 0,
                     (format == OPENGL_DEPTH_COMPONENT_KIND) ? GL_DEPTH_COMPONENT : GL_BGRA_EXT,
                     GL_UNSIGNED_BYTE, 0);
    }
    
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filter_kind);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter_kind);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    return result;
}

internal void
free_framebuffer(Opengl_Framebuffer* framebuffer) {
    if (framebuffer->framebuffer_handle) {
        glDeleteFramebuffers(1, &framebuffer->framebuffer_handle);
        framebuffer->framebuffer_handle = 0;
    }
    
    for (u32 color_index = 0;
         color_index < ARRAY_COUNT(framebuffer->color_handle);
         ++color_index) {
        if (framebuffer->color_handle[color_index]) {
            glDeleteTextures(1, &framebuffer->color_handle[color_index]);
            framebuffer->color_handle[color_index] = 0;
        }
    }
    
    if (framebuffer->depth_handle) {
        glDeleteTextures(1, &framebuffer->depth_handle);
        framebuffer->depth_handle = 0;
    }
}

internal Opengl_Framebuffer
create_framebuffer(Opengl* opengl, u32 width, u32 height,
                   u32 flags, u32 color_buffer_count) {
    ASSERT(glGetError() == GL_NO_ERROR);
    
    Opengl_Framebuffer result = {};
    
    b32 multisampled = flags & Opengl_Framebuffer_Flags::MULTISAMPLED;
    b32 filtered = flags & Opengl_Framebuffer_Flags::FILTERED;
    b32 has_depth = flags & Opengl_Framebuffer_Flags::DEPTH;
    b32 is_float = flags & Opengl_Framebuffer_Flags::FLOAT;
    
    glGenFramebuffers(1, &result.framebuffer_handle);
    glBindFramebuffer(GL_FRAMEBUFFER, result.framebuffer_handle);
    
    GLuint slot = multisampled ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D;
    GLint filter_kind = filtered ? GL_LINEAR : GL_NEAREST;
    
    ASSERT(color_buffer_count <=
           ARRAY_COUNT(opengl_all_color_attachments));
    ASSERT(color_buffer_count <=
           ARRAY_COUNT(result.color_handle));
    
    for (u32 color_index = 0;
         color_index < color_buffer_count;
         ++color_index) {
        result.color_handle[color_index] =
            framebuffer_tex_image(opengl, slot, width, height,
                                  filter_kind, (color_index == 0) ? opengl->default_framebuffer_texture_format : GL_RGBA8);
        glFramebufferTexture2D(GL_FRAMEBUFFER,
                               GL_COLOR_ATTACHMENT0 + color_index,
                               slot, result.color_handle[color_index],
                               0);
    }
    
    glDrawBuffers(color_buffer_count, opengl_all_color_attachments);
    
    if (has_depth) {
        result.depth_handle =
            framebuffer_tex_image(opengl, slot, width, height,
                                  filter_kind, OPENGL_DEPTH_COMPONENT_KIND);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                               slot, result.depth_handle, 0);
    }
    
    GLenum framebuffer_status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    ASSERT(framebuffer_status == GL_FRAMEBUFFER_COMPLETE);
    
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glBindTexture(slot, 0);
    
    return result;
}

internal void
opengl_change_to_settings(Opengl* opengl, Render_Settings* settings) {
    //free_framebuffer(&opengl->resolve_famebuffer);
    
    /*for (u32 depth_peel_index = 0;
    depth_peel_index < opengl->depth_peel_count;
    ++depth_peel_index) {
    free_framebuffer(&opengl->depth_peel_buffer[depth_peel_index]);
    free_framebuffer(&opengl->depth_peel_resolve_buffer[depth_peel_index]);
    }*/
    
    free_framebuffer(&opengl->resolve_framebuffer);
    
    
    free_program(&opengl->z_bias_no_depth_peel.common);
    free_program(&opengl->z_bias_depth_peel.common);
    free_program(&opengl->peel_composite);
    free_program(&opengl->final_stretch);
    
    opengl->current_settings = *settings;
    opengl->multisampling = settings->multisampling_hint;
    opengl->depth_peel_count = settings->depth_peel_count_hint;
    
    u32 resolve_flags = 0;
    if(!settings->pixelation_hint)
    {
        resolve_flags |= Opengl_Framebuffer_Flags::FILTERED;
    }
    
    u32 render_width = settings->render_dim.width;
    u32 render_height = settings->render_dim.height;
    
    compile_z_bias_program(opengl, &opengl->z_bias_no_depth_peel,
                           false, true);
    compile_z_bias_program(opengl, &opengl->z_bias_depth_peel,
                           true, true);
    compile_peel_composite(opengl, &opengl->peel_composite);
    compile_final_stretch(opengl, &opengl->final_stretch);
    
    opengl->resolve_framebuffer =
        create_framebuffer(opengl, render_width, render_height,
                           resolve_flags, 1);
}

internal void
opengl_init(Opengl* opengl, Opengl_Info info,
            b32 framebuffer_supports_srgb) {
    opengl->current_settings.depth_peel_count_hint = 4;
    opengl->current_settings.multisampling_hint = true;
    opengl->current_settings.pixelation_hint = false;
    opengl->current_settings.multisampling_debug = false;
    opengl->current_settings.request_vsync = true;
    
    opengl->shader_sim_tex_read_srgb = true;
    opengl->shader_sim_tex_write_srgb = true;
    
    glGenTextures(1, &opengl->reserved_blit_texture);
    
    glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS,
                  &opengl->max_color_attachments);
    glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,
                  &opengl->max_samplers_per_shader);
    
    glGetIntegerv(GL_MAX_COLOR_TEXTURE_SAMPLES,
                  &opengl->max_multisample_count);
    if (opengl->max_multisample_count > 16) {
        opengl->max_multisample_count = 16;
    }
    
    opengl->default_sprite_texture_format = GL_RGBA8;
    opengl->default_framebuffer_texture_format = GL_RGBA8;
    
    GLuint dummy_vertex_array;
    glGenVertexArrays(1, &dummy_vertex_array);
    glBindVertexArray(dummy_vertex_array);
    
    glGenBuffers(1, &opengl->vertex_buffer);
    glGenBuffers(1, &opengl->index_buffer);
    
    glGenBuffers(1, &opengl->screen_fill_vertex_buffer);
    glBindBuffer(GL_ARRAY_BUFFER, opengl->screen_fill_vertex_buffer);
    Textured_Vertex vertices[] = {
        {{-1.0f,  1.0f, 0.0f, 1.0f}, {}, {0.0f, 1.0f}, 0xFFFFFFFF},
        {{-1.0f, -1.0f, 0.0f, 1.0f}, {}, {0.0f, 0.0f}, 0xFFFFFFFF},
        {{ 1.0f,  1.0f, 0.0f, 1.0f}, {}, {1.0f, 1.0f}, 0xFFFFFFFF},
        {{ 1.0f, -1.0f, 0.0f, 1.0f}, {}, {1.0f, 0.0f}, 0xFFFFFFFF}
    };
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices),
                 vertices, GL_STATIC_DRAW);
    
    for (u32 y = 0; y < 4; ++y) {
        for (u32 x = 0; x < 4; ++x) {
            opengl->white[y][x] = 0xFFFFFFFF;
        }
    }
    
    glGenTextures(1, &opengl->texture_array);
    glBindTexture(GL_TEXTURE_2D_ARRAY, opengl->texture_array);
    
    glTexImage3D(GL_TEXTURE_2D_ARRAY, 0,
                 opengl->default_sprite_texture_format,
                 TEXTURE_ARRAY_DIM, TEXTURE_ARRAY_DIM,
                 opengl->max_texture_count, 0,
                 GL_BGRA_EXT, GL_UNSIGNED_BYTE, 0);
    
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S,
                    GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T,
                    GL_CLAMP_TO_EDGE);
    
    glGenTextures(opengl->max_special_texture_count,
                  opengl->special_texture_handles);
    for (u32 handle_index = 0;
         handle_index < opengl->max_special_texture_count;
         ++handle_index) {
        GLuint handle = opengl->special_texture_handles[handle_index];
        glBindTexture(GL_TEXTURE_2D_ARRAY, handle);
        
        
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S,
                        GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T,
                        GL_CLAMP_TO_EDGE);
    }
    
    glBindTexture(GL_TEXTURE_2D, 0);
}

internal Render_Commands*
opengl_begin_frame(Opengl* opengl,
                   u32 window_width, u32 window_height,
                   Rectangle2i draw_region) {
    Render_Commands* commands = &opengl->render_commands;
    
    commands->settings = opengl->current_settings;
    
    commands->os_window_dim.width = window_width;
    commands->os_window_dim.height = window_height;
    commands->os_draw_region = draw_region;
    
    commands->max_push_buffer_size = sizeof(opengl->push_buffer_memory);
    commands->push_buffer_base = opengl->push_buffer_memory;
    commands->push_buffer_data_at = opengl->push_buffer_memory;
    
    commands->max_vertex_count = opengl->max_vertex_count;
    commands->vertex_count = 0;
    commands->vertex_array = opengl->vertex_array;
    
    commands->max_index_count = opengl->max_index_count;
    commands->index_count = 0;
    commands->index_array = opengl->index_array;
    
    commands->max_quad_texture_count = opengl->max_quad_texture_count;
    commands->quad_texture_count = 0;
    commands->quad_textures = opengl->bitmap_array;
    
    return commands;
}

internal void
opengl_end_frame(Opengl* opengl,
                 Render_Commands* commands) {
    Rectangle2i draw_region = commands->os_draw_region;
    u32 window_width = commands->os_window_dim.width;
    u32 window_height = commands->os_window_dim.height;
    
    glDepthMask(GL_TRUE);
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);
    glEnable(GL_MULTISAMPLE);
    
    glEnable(GL_SCISSOR_TEST);
    glDisable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
    
    glBindBuffer(GL_ARRAY_BUFFER, opengl->vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER,
                 commands->vertex_count * sizeof(Textured_Vertex),
                 commands->vertex_array,
                 GL_STREAM_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, opengl->index_buffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                 commands->index_count * sizeof(u16),
                 commands->index_array,
                 GL_STREAM_DRAW);
    
    if (!settings_match(&commands->settings, &opengl->current_settings)) {
        opengl_change_to_settings(opengl, &commands->settings);
    }
    
    opengl_manage_textures(opengl, &opengl->header.texture_queue);
    
    b32 use_render_targets = (glBindFramebuffer != 0);
    ASSERT(use_render_targets);
    
    Render_Settings* settings = &commands->settings;
    u32 render_width = settings->render_dim.width;
    u32 render_height = settings->render_dim.height;
    
    glClearDepth(1.0f);
    
    ASSERT(opengl->depth_peel_count > 0);
    u32 max_render_target_index = opengl->depth_peel_count - 1;
    u32 on_peel_index = 0;
    u8* peel_header_restore = 0;
    u32 current_render_target_index = 0xFFFFFFFF;
    Matrix4x4 proj = identity();
    for (u8* header_at = commands->push_buffer_base;
         header_at < commands->push_buffer_data_at;) {
        Render_Group_Entry_Header* header =
            (Render_Group_Entry_Header*)header_at;
        header_at += sizeof(Render_Group_Entry_Header);
        void* data = (u8*)header + sizeof(*header);
        
        switch (header->kind) {
            /*
            case Render_Group_Entry_Kind::FULL_CLEAR: {
            
            } break;
            
            case Render_Group_Entry_Kind::BEGIN_PEELS: {
            
            } break;
            
            case Render_Group_Entry_Kind::END_PEELS: {
            
            } break;
            
            case Render_Group_Entry_Kind::DEPTH_CLEAR: {
            
            } break;
            */
            case Render_Group_Entry_Kind::TEXTURED_QUADS: {
                glBindBuffer(GL_ARRAY_BUFFER, opengl->vertex_buffer);
                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                             opengl->index_buffer);
                
                header_at += sizeof(Render_Entry_Textured_Quads);
                Render_Entry_Textured_Quads* entry =
                    (Render_Entry_Textured_Quads*)data;
                
                b32 peeling = (on_peel_index > 0);
                
                Render_Setup* setup = &entry->setup;
                
                Rectangle2 clip_rect = setup->clip_rect;
                s32 clip_min_x = s32_binormal_lerp(0, clip_rect.min.x,
                                                   render_width);
                s32 clip_min_y = s32_binormal_lerp(0, clip_rect.min.y,
                                                   render_height);
                s32 clip_max_x = s32_binormal_lerp(0, clip_rect.max.x,
                                                   render_width);
                s32 clip_max_y = s32_binormal_lerp(0, clip_rect.max.y,
                                                   render_height);
                glScissor(clip_min_x, clip_min_y,
                          clip_max_x - clip_min_x,
                          clip_max_y - clip_min_y);
                
                Z_Bias_Program* prog = &opengl->z_bias_no_depth_peel;
                f32 alpha_threshold = 0.0f;
                
                /*
                if (peeling) {
                Opengl_Framebuffer* peel_buffer =
                get_depth_peel_read_buffer(opengl,
                on_peel_index - 1);
                prog = &opengl->z_bias_depth_peel;
                glActiveTexture(GL_TEXTURE1);
                glBindTexture(GL_TEXTURE_2D,
                peel_buffer->depth_handle);
                glActiveTexture(GL_TEXTURE0);
                
                if (on_depth_peel == max_render_target_index) {
                alpha_threshold = 0.9f;
                }
                }
                */
                
                /*
                glActiveTexture(GL_TEXTURE2);
                glBindTexture(GL_TEXTURE_1D, opengl->light_data_0);
                glActiveTexture(GL_TEXTURE3);
                glBindTexture(GL_TEXTURE_1D, opengl->light_data_1);
                glActiveTexture(GL_TEXTURE0);
                */
                
                use_program_begin(prog, setup, alpha_threshold);
                
                if (entry->quad_textures) {
                    // NOTE(yuval): This is the multiple-dispatch slow path, for
                    // arbitrary sized textures
                    u32 index_index = entry->index_array_offset;
                    
                    for (u32 quad_index = 0;
                         quad_index < entry->quad_count;
                         ++quad_index) {
                        Renderer_Texture texture =
                            entry->quad_textures[quad_index];
                        GLuint texture_handle =
                            get_special_texture_handle_for(opengl, texture);
                        glBindTexture(GL_TEXTURE_2D_ARRAY, texture_handle);
                        glDrawElementsBaseVertex(
                            GL_TRIANGLES, 6, GL_UNSIGNED_SHORT,
                            (GLvoid*)(index_index * sizeof(u16)),
                            entry->vertex_array_offset);
                        index_index += (6 * quad_index);
                    }
                } else {
                    // NOTE(yuval): This is the single-dispatch fast path, for texture arrays
                    glBindTexture(GL_TEXTURE_2D_ARRAY,
                                  opengl->texture_array);
                    glDrawElementsBaseVertex(
                        GL_TRIANGLES, 6 * entry->quad_count,
                        GL_UNSIGNED_SHORT,
                        (GLvoid*)(entry->index_array_offset * sizeof(u16)),
                        entry->vertex_array_offset);
                }
                
                glBindTexture(GL_TEXTURE_2D_ARRAY, 0);
                use_program_end(&prog->common);
                
                if (peeling) {
                    glActiveTexture(GL_TEXTURE1);
                    glBindTexture(GL_TEXTURE_2D, 0);
                    glActiveTexture(GL_TEXTURE0);
                }
            } break;
            
            /*case Render_Group_Entry_Kind::LIGHTING_TRANSFER: {
            
            } break;
            */
            // TODO(yuval): Diagnose if default case is hit
        }
    }
    
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
    
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER,
                      opengl->resolve_framebuffer.framebuffer_handle);
    glViewport(0, 0, render_width, render_height);
    glScissor(0, 0, render_width, render_height);
    glBindBuffer(GL_ARRAY_BUFFER, opengl->screen_fill_vertex_buffer);
    
    /*
    use_program_begin(&opengl->peel_composite);
    u32 texture_bind_index = GL_TEXTURE0;
    for (u32 peel_index = 0;
    peel_index < max_render_target_index;
    ++peel_index) {
    Opengl_Framebuffer* peel_buffer =
    get_depth_peel_read_buffer(opengl, peel_index);
    glActiveTexture(texture_bind_index++);
    glBindTexture(GL_TEXTURE_2D,
    peel_buffer->color_handle[Opengl_Color_Handle_Kind::SURFACE_REFLECT]);
    }
    
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glActiveTexture(GL_TEXTURE0);
    use_program_end(&opengl->peel_composite);
    */
    
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
    
    glViewport(0, 0, window_width, window_height);
    glScissor(0, 0, window_width, window_height);
    glClearColor(0, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT);
    
    glViewport(draw_region.min_x, draw_region.min_y,
               get_width(draw_region), get_height(draw_region));
    glScissor(draw_region.min_x, draw_region.min_y,
              get_width(draw_region), get_height(draw_region));
    
    use_program_begin(&opengl->final_stretch);
    glBindTexture(GL_TEXTURE_2D,
                  opengl->resolve_framebuffer.color_handle[0]);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE0);
    use_program_end(&opengl->final_stretch);
}
